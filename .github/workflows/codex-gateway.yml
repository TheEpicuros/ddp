name: codex-gateway

on:
  issues:
    types: [opened, edited, labeled]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  gateway:
    # Run if the issue already has the label OR if this event is the act of labeling it
    if: contains(github.event.issue.labels.*.name, 'codex-task') || (github.event.action == 'labeled' && github.event.label.name == 'codex-task')
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.CODEX_PAT }}   # used for contents & PRs

    steps:
      - name: Install jq
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Parse request JSON from issue body
        id: parse
        shell: bash
        run: |
          set -euo pipefail
          body=$(jq -r '.issue.body' "$GITHUB_EVENT_PATH")
          echo "$body" | jq -e . > /tmp/req.json
          echo "path=$(jq -r '.path' /tmp/req.json)"             >> "$GITHUB_OUTPUT"
          echo "message=$(jq -r '.message' /tmp/req.json)"       >> "$GITHUB_OUTPUT"
          echo "title=$(jq -r '.title' /tmp/req.json)"           >> "$GITHUB_OUTPUT"
          # default content_mode to "text" without over-escaping
          echo "content_mode=$(jq -r '.content_mode // "text"' /tmp/req.json)" >> "$GITHUB_OUTPUT"
          echo "branch_prefix=$(jq -r '.branch_prefix // empty' /tmp/req.json)"  >> "$GITHUB_OUTPUT"

      # Strict schema guard (required keys + content_mode enum)
      - name: Validate required fields
        id: validate
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          jq -e '
            type=="object"
            and has("path")
            and has("message")
            and has("title")
            and has("content_mode")
            and has("content")
            and (.content_mode=="text" or .content_mode=="base64")
          ' /tmp/req.json >/dev/null

      # On validation failure, compute a helpful message
      - name: Compose schema error
        if: steps.validate.outcome == 'failure'
        id: schemaerr
        shell: bash
        run: |
          set -euo pipefail
          missing=""
          for k in path message title content_mode content; do
            if [ "$(jq -r --arg k "$k" 'has($k)' /tmp/req.json)" != "true" ]; then
              missing="${missing}${k}, "
            fi
          done
          if [ -n "$missing" ]; then
            missing="Missing required key(s): ${missing%, }."
          fi

          cm_ok="$(jq -r 'if has("content_mode") then (.content_mode=="text" or .content_mode=="base64") else "n/a" end' /tmp/req.json)"
          cm_msg=""
          if [ "$cm_ok" = "false" ]; then
            got="$(jq -r '.content_mode' /tmp/req.json)"
            cm_msg=" Invalid content_mode: \"$got\". Allowed: \"text\" or \"base64\"."
          fi

          msg="Schema validation failed.${missing}${cm_msg} Provide a JSON body like:
          {
            \"path\": \"codex/your-file.txt\",
            \"message\": \"commit message\",
            \"title\": \"Codex: your PR title\",
            \"content_mode\": \"text\",
            \"content\": \"file contents\",
            \"branch_prefix\": \"codex\"
          }"
          printf '%s\n' "$msg" > /tmp/schema_error.txt
          echo "msg<<EOF" >> "$GITHUB_OUTPUT"
          cat /tmp/schema_error.txt >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      # Comment error back on the issue using the default GITHUB_TOKEN
      - name: Comment schema error
        if: steps.validate.outcome == 'failure'
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        shell: bash
        run: |
          set -euo pipefail
          gh api "repos/$GITHUB_REPOSITORY/issues/${ISSUE_NUMBER}/comments" -X POST \
            -f body="${{ steps.schemaerr.outputs.msg }}"

      # Abort run cleanly if schema invalid
      - name: Stop on schema failure
        if: steps.validate.outcome == 'failure'
        shell: bash
        run: |
          echo "Stopping run due to schema validation failure."
          exit 1

      # If schema is valid, continue with normal flow
      - name: Validate path allowlist
        if: steps.validate.outcome == 'success'
        shell: bash
        run: |
          set -euo pipefail
          case "${{ steps.parse.outputs.path }}" in
            codex/*) echo "Path allowed";;
            *) echo "ERROR: Path must start with 'codex/'"; exit 1;;
          esac

      - name: Derive values (use default branch dynamically)
        if: steps.validate.outcome == 'success'
        id: derive
        shell: bash
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          set -euo pipefail
          base="${DEFAULT_BRANCH:-main}"
          sha=$(gh api "repos/$GITHUB_REPOSITORY/git/ref/heads/$base" --jq '.object.sha')
          short=${sha:0:8}
          when=$(date +%s)
          prefix="${{ steps.parse.outputs.branch_prefix }}"
          if [ -z "$prefix" ]; then prefix="codex"; fi
          branch="$prefix-$short-$when"
          echo "sha=$sha" >> "$GITHUB_OUTPUT"
          echo "branch=$branch" >> "$GITHUB_OUTPUT"
          echo "base=$base" >> "$GITHUB_OUTPUT"

      - name: Create branch
        if: steps.validate.outcome == 'success'
        shell: bash
        run: |
          set -euo pipefail
          gh api "repos/$GITHUB_REPOSITORY/git/refs" -X POST \
            -f ref="refs/heads/${{ steps.derive.outputs.branch }}" \
            -f sha="${{ steps.derive.outputs.sha }}"

      - name: Prepare file content
        if: steps.validate.outcome == 'success'
        id: content
        shell: bash
        run: |
          set -euo pipefail
          mode="${{ steps.parse.outputs.content_mode }}"
          if [ "$mode" = "base64" ]; then
            jq -r '.content' /tmp/req.json > /tmp/content.b64
          else
            jq -r '.content' /tmp/req.json | base64 -w0 > /tmp/content.b64
          fi

      - name: Create or update file via Contents API
        if: steps.validate.outcome == 'success'
        id: put
        shell: bash
        run: |
          set -euo pipefail
          path="${{ steps.parse.outputs.path }}"
          msg="${{ steps.parse.outputs.message }}"
          branch="${{ steps.derive.outputs.branch }}"
          b64=$(cat /tmp/content.b64)
          sha=$(gh api -X GET "repos/$GITHUB_REPOSITORY/contents/$path?ref=$branch" --jq .sha 2>/dev/null || true)
          if [ -n "$sha" ]; then
            gh api -X PUT "repos/$GITHUB_REPOSITORY/contents/$path" \
              -f message="$msg" -f content="$b64" -f branch="$branch" -f sha="$sha" >/dev/null
          else
            gh api -X PUT "repos/$GITHUB_REPOSITORY/contents/$path" \
              -f message="$msg" -f content="$b64" -f branch="$branch" >/dev/null
          fi
          echo "changed_path=$path" >> "$GITHUB_OUTPUT"

      - name: Open PR
        if: steps.validate.outcome == 'success'
        id: pr
        shell: bash
        run: |
          set -euo pipefail
          title="${{ steps.parse.outputs.title }}"
          branch="${{ steps.derive.outputs.branch }}"
          base="${{ steps.derive.outputs.base }}"
          url=$(gh api "repos/$GITHUB_REPOSITORY/pulls" -X POST \
              -f title="$title" -f head="$branch" -f base="$base" \
              -f body="Gateway PR opened by codex-gateway." --jq .html_url)
          echo "url=$url" >> "$GITHUB_OUTPUT"

      - name: Comment back on issue (success path; uses GITHUB_TOKEN)
        if: steps.validate.outcome == 'success'
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          gh api "repos/$GITHUB_REPOSITORY/issues/${{ github.event.issue.number }}/comments" -X POST \
            -f body="Opened PR: ${{ steps.pr.outputs.url }} (changed: ${{ steps.put.outputs.changed_path }})"
