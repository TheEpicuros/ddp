name: codex-gateway

on:
  issues:
    types: [opened, edited, labeled]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  gateway:
    runs-on: ubuntu-latest

    # Force bash everywhere
    defaults:
      run:
        shell: bash

    env:
      GH_TOKEN: ${{ secrets.CODEX_PAT }}   # used for gh api calls (contents & PRs)

    steps:
      - name: Show shell
        run: |
          echo "SHELL=$SHELL"
          bash --version | head -n 1 || true

      - name: Install jq
        run: |
          set -euo pipefail
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      # ───────────────────────────
      # Gate: require codex-task label
      # ───────────────────────────
      - name: Gate on codex-task label
        id: gate
        run: |
          set -euo pipefail
          HAS_LABEL="$(jq -r '(.issue.labels // []) | any(.name == "codex-task")' "$GITHUB_EVENT_PATH")"
          LABELED_THIS="$(jq -r '(.action == "labeled") and (.label.name == "codex-task")' "$GITHUB_EVENT_PATH")"
          echo "EVENT=$(jq -r '.action' "$GITHUB_EVENT_PATH")"
          echo "TITLE=$(jq -r '.issue.title' "$GITHUB_EVENT_PATH")"
          if [ "$HAS_LABEL" = "true" ] || [ "$LABELED_THIS" = "true" ]; then
            echo "run=yes" >> "$GITHUB_OUTPUT"
            echo "Proceeding (label present or just added)."
          else
            echo "run=no" >> "$GITHUB_OUTPUT"
            echo "No codex-task label yet; exiting cleanly."
          fi

      - name: Parse request JSON from issue body
        id: parse
        if: steps.gate.outputs.run == 'yes'
        run: |
          set -euo pipefail
          body=$(jq -r '.issue.body' "$GITHUB_EVENT_PATH")
          # Body must be strict JSON (no code fences). Parse strictly:
          echo "$body" | jq -e . > /tmp/req.json
          echo "path=$(jq -r '.path' /tmp/req.json)"               >> "$GITHUB_OUTPUT"
          echo "message=$(jq -r '.message' /tmp/req.json)"         >> "$GITHUB_OUTPUT"
          echo "title=$(jq -r '.title' /tmp/req.json)"             >> "$GITHUB_OUTPUT"
          echo "content_mode=$(jq -r '.content_mode // "text"' /tmp/req.json)" >> "$GITHUB_OUTPUT"
          echo "branch_prefix=$(jq -r '.branch_prefix // empty' /tmp/req.json)"  >> "$GITHUB_OUTPUT"

      # Strict schema guard (required keys + content_mode enum)
      - name: Validate required fields
        id: validate
        if: steps.gate.outputs.run == 'yes'
        continue-on-error: true
        run: |
          set -euo pipefail
          jq -e '
            type=="object"
            and has("path")
            and has("message")
            and has("title")
            and has("content_mode")
            and has("content")
            and (.content_mode=="text" or .content_mode=="base64")
          ' /tmp/req.json >/dev/null

      - name: Compose schema error
        id: schemaerr
        if: steps.gate.outputs.run == 'yes' && steps.validate.outcome == 'failure'
        run: |
          set -euo pipefail
          missing=""
          for k in path message title content_mode content; do
            if [ "$(jq -r --arg k "$k" 'has($k)' /tmp/req.json)" != "true" ]; then
              missing="${missing}${k}, "
            fi
          done
          [ -n "$missing" ] && missing="Missing required key(s): ${missing%, }."
          cm_ok="$(jq -r 'if has("content_mode") then (.content_mode=="text" or .content_mode=="base64") else "n/a" end' /tmp/req.json)"
          cm_msg=""
          if [ "$cm_ok" = "false" ]; then
            got="$(jq -r '.content_mode' /tmp/req.json)"
            cm_msg=" Invalid content_mode: \"$got\". Allowed: \"text\" or \"base64\"."
          fi
          msg="Schema validation failed. ${missing}${cm_msg}
          Provide a JSON body like:
          {
            \"path\": \"codex/your-file.txt\",
            \"message\": \"commit message\",
            \"title\": \"Codex: your PR title\",
            \"content_mode\": \"text\",
            \"content\": \"file contents\",
            \"branch_prefix\": \"codex\"
          }"
          printf '%s\n' "$msg" > /tmp/schema_error.txt
          echo "msg<<EOF" >> "$GITHUB_OUTPUT"
          cat /tmp/schema_error.txt >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Comment schema error
        if: steps.gate.outputs.run == 'yes' && steps.validate.outcome == 'failure'
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          set -euo pipefail
          gh api "repos/$GITHUB_REPOSITORY/issues/${ISSUE_NUMBER}/comments" -X POST \
            -f body="${{ steps.schemaerr.outputs.msg }}"

      - name: Stop on schema failure
        if: steps.gate.outputs.run == 'yes' && steps.validate.outcome == 'failure'
        run: |
          echo "Stopping run due to schema validation failure."
          exit 1

      # Size guard (text mode only)
      - name: Validate content size (text mode)
        id: sizeguard
        if: steps.gate.outputs.run == 'yes'
        continue-on-error: true
        run: |
          set -euo pipefail
          mode="$(jq -r '.content_mode // "text"' /tmp/req.json)"
          if [ "$mode" = "text" ]; then
            bytes=$(jq -r '.content' /tmp/req.json | wc -c | awk '{print $1}')
            limit=$((150*1024)) # 150 KB
            echo "content_bytes=$bytes limit=$limit"
            if [ "$bytes" -gt "$limit" ]; then
              echo "too_big=true" >> "$GITHUB_OUTPUT"
              exit 1
            fi
          fi

      - name: Comment size error
        if: steps.gate.outputs.run == 'yes' && steps.sizeguard.outcome == 'failure'
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          set -euo pipefail
          gh api "repos/$GITHUB_REPOSITORY/issues/${ISSUE_NUMBER}/comments" -X POST \
            -f body="Content too large for \"text\" mode. Use \"content_mode\": \"base64\" and put base64-encoded content in \"content\" (suggest splitting files >150 KB)."

      - name: Stop on size failure
        if: steps.gate.outputs.run == 'yes' && steps.sizeguard.outcome == 'failure'
        run: |
          echo "Stopping run due to content size guard."
          exit 1

      - name: Validate path allowlist
        if: steps.gate.outputs.run == 'yes'
        run: |
          set -euo pipefail
          case "${{ steps.parse.outputs.path }}" in
            codex/*) echo "Path allowed";;
            *) echo "ERROR: Path must start with 'codex/'"; exit 1;;
          esac

      - name: Derive values (use default branch dynamically)
        id: derive
        if: steps.gate.outputs.run == 'yes'
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          set -euo pipefail
          base="${DEFAULT_BRANCH:-main}"
          sha=$(gh api "repos/$GITHUB_REPOSITORY/git/ref/heads/$base" --jq '.object.sha')
          short=${sha:0:8}
          when=$(date +%s)
          prefix="${{ steps.parse.outputs.branch_prefix }}"
          [ -z "$prefix" ] && prefix="codex"
          branch="$prefix-$short-$when"
          echo "sha=$sha" >> "$GITHUB_OUTPUT"
          echo "branch=$branch" >> "$GITHUB_OUTPUT"
          echo "base=$base" >> "$GITHUB_OUTPUT"

      - name: Create branch
        if: steps.gate.outputs.run == 'yes'
        run: |
          set -euo pipefail
          gh api "repos/$GITHUB_REPOSITORY/git/refs" -X POST \
            -f ref="refs/heads/${{ steps.derive.outputs.branch }}" \
            -f sha="${{ steps.derive.outputs.sha }}"

      - name: Prepare file content
        id: content
        if: steps.gate.outputs.run == 'yes'
        run: |
          set -euo pipefail
          mode="${{ steps.parse.outputs.content_mode }}"
          if [ "$mode" = "base64" ]; then
            jq -r '.content' /tmp/req.json > /tmp/content.b64
          else
            jq -r '.content' /tmp/req.json | base64 -w0 > /tmp/content.b64
          fi

      - name: Create or update file via Contents API
        id: put
        if: steps.gate.outputs.run == 'yes'
        run: |
          set -euo pipefail
          path="${{ steps.parse.outputs.path }}"
          msg="${{ steps.parse.outputs.message }}"
          branch="${{ steps.derive.outputs.branch }}"
          b64=$(cat /tmp/content.b64)
          sha=$(gh api -X GET "repos/$GITHUB_REPOSITORY/contents/$path?ref=$branch" --jq .sha 2>/dev/null || true)
          if [ -n "$sha" ]; then
            gh api -X PUT "repos/$GITHUB_REPOSITORY/contents/$path" \
              -f message="$msg" -f content="$b64" -f branch="$branch" -f sha="$sha" >/dev/null
          else
            gh api -X PUT "repos/$GITHUB_REPOSITORY/contents/$path" \
              -f message="$msg" -f content="$b64" -f branch="$branch" >/dev/null
          fi
          echo "changed_path=$path" >> "$GITHUB_OUTPUT"

      - name: Open PR
        id: pr
        if: steps.gate.outputs.run == 'yes'
        run: |
          set -euo pipefail
          title="${{ steps.parse.outputs.title }}"
          branch="${{ steps.derive.outputs.branch }}"
          base="${{ steps.derive.outputs.base }}"
          url=$(gh api "repos/$GITHUB_REPOSITORY/pulls" -X POST \
              -f title="$title" -f head="$branch" -f base="$base" \
              -f body="Gateway PR opened by codex-gateway." --jq .html_url)
          echo "url=$url" >> "$GITHUB_OUTPUT"

      - name: Comment back on issue (success path; uses GITHUB_TOKEN)
        if: steps.gate.outputs.run == 'yes'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          gh api "repos/$GITHUB_REPOSITORY/issues/${{ github.event.issue.number }}/comments" -X POST \
            -f body="Opened PR: ${{ steps.pr.outputs.url }} (changed: ${{ steps.put.outputs.changed_path }})"
